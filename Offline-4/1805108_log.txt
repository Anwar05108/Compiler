line number1: type_specifier : INT

int

line number1: type_specifier : INT

int

line number1: parameter_list : type_specifier ID

int a

line number2: factor : CONST_INT

2

line number2: unary_expression : factor

2

line number2: term : unary_expression

2

line number2: variable : ID

a

line number2: factor : variable

a

line number2: unary_expression : factor

a

line number2: term : term MULOP unary_expression

2*a

line number2: simple_expression : term

2*a

line number2: expression : simple expression

2*a

line number2: logic_expression : rel_expression

2*a

line number2: expression : logic expression

2*a

line number2: statement : RETURN expression

return 2*a;

line number2: statement_list : statement

return 2*a;

line number3: variable : ID

a

line number3: factor : CONST_INT

9

line number3: unary_expression : factor

9

line number3: term : unary_expression

9

line number3: simple_expression : term

9

line number3: expression : simple expression

9

line number3: logic_expression : rel_expression

9

line number3: expression : variable ASSIGNOP logic expression

a=9

line number3: expression_statement : expression SEMICOLON

a=9;

line number3: statement : expression_statement

a=9;

line number3: statement_list : statement_list statement

return 2*a;
a=9;

line number4: compound_statement : LCURL statement_list RCURL

{
return 2*a;
a=9;
}

print all scopes
 ScopeTable: 1_1

7--> < a ,ID >
 ScopeTable: 1

12--> < f ,ID >
line number4: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int f ( int a ) {
return 2*a;
a=9;
}


line number4: unit: function_definition 

int f ( int a ) {
return 2*a;
a=9;
}


line number4: program:  unit 

int f ( int a ) {
return 2*a;
a=9;
}


line number6: type_specifier : INT

int

line number6: type_specifier : INT

int

line number6: parameter_list : type_specifier ID

int a

line number6: type_specifier : INT

int

line number6: parameter_list : parameter_list COMMA type_specifier ID

int a,int b

line number7: type_specifier : INT

int

line number7: declaration_list: ID 

x

line number7: variable_declaration: type_specifier declaration_list SEMICOLON 

int x;

line number7: statement : variable_declaration

int x;

line number7: statement_list : statement

int x;

line number8: variable : ID

x

line number8: variable : ID

a

line number8: factor : variable

a

line number8: unary_expression : factor

a

line number8: term : unary_expression

a

line number8: simple_expression : term

a

line number8: expression : simple expression

a

line number8: logic_expression : rel_expression

a

line number8: argument_list : logic_expression

a

line number8: argument_list : arguments

a

line number8: factor : ID LPAREN argument_list RPAREN

f ( a )

line number8: unary_expression : factor

f ( a )

line number8: term : unary_expression

f ( a )

line number8: simple_expression : term

f ( a )

line number8: variable : ID

a

line number8: factor : variable

a

line number8: unary_expression : factor

a

line number8: term : unary_expression

a

line number8: simple_expression : simple_expression ADDOP term

f ( a )+a

line number8: variable : ID

b

line number8: factor : variable

b

line number8: unary_expression : factor

b

line number8: term : unary_expression

b

line number8: simple_expression : simple_expression ADDOP term

f ( a )+a+b

line number8: expression : simple expression

f ( a )+a+b

line number8: logic_expression : rel_expression

f ( a )+a+b

line number8: expression : variable ASSIGNOP logic expression

x=f ( a )+a+b

line number8: expression_statement : expression SEMICOLON

x=f ( a )+a+b;

line number8: statement : expression_statement

x=f ( a )+a+b;

line number8: statement_list : statement_list statement

int x;
x=f ( a )+a+b;

line number9: variable : ID

x

line number9: factor : variable

x

line number9: unary_expression : factor

x

line number9: term : unary_expression

x

line number9: simple_expression : term

x

line number9: expression : simple expression

x

line number9: logic_expression : rel_expression

x

line number9: expression : logic expression

x

line number9: statement : RETURN expression

return x;

line number9: statement_list : statement_list statement

int x;
x=f ( a )+a+b;
return x;

line number10: compound_statement : LCURL statement_list RCURL

{
int x;
x=f ( a )+a+b;
return x;
}

print all scopes
 ScopeTable: 1_2

0--> < x ,ID >
7--> < a ,ID >
8--> < b ,ID >
 ScopeTable: 1

12--> < f ,ID >
13--> < g ,ID >
line number10: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int g ( int a,int b ) {
int x;
x=f ( a )+a+b;
return x;
}


line number10: unit: function_definition 

int g ( int a,int b ) {
int x;
x=f ( a )+a+b;
return x;
}


line number10: program: program unit 

int f ( int a ) {
return 2*a;
a=9;
}

int g ( int a,int b ) {
int x;
x=f ( a )+a+b;
return x;
}


line number12: type_specifier : INT

int

line number13: type_specifier : INT

int

line number13: declaration_list: ID 

a

line number13: declaration_list: declaration_list COMMA ID 

a,b

line number13: variable_declaration: type_specifier declaration_list SEMICOLON 

int a,b;

line number13: statement : variable_declaration

int a,b;

line number13: statement_list : statement

int a,b;

line number14: variable : ID

a

line number14: factor : CONST_INT

1

line number14: unary_expression : factor

1

line number14: term : unary_expression

1

line number14: simple_expression : term

1

line number14: expression : simple expression

1

line number14: logic_expression : rel_expression

1

line number14: expression : variable ASSIGNOP logic expression

a=1

line number14: expression_statement : expression SEMICOLON

a=1;

line number14: statement : expression_statement

a=1;

line number14: statement_list : statement_list statement

int a,b;
a=1;

line number15: variable : ID

b

line number15: factor : CONST_INT

2

line number15: unary_expression : factor

2

line number15: term : unary_expression

2

line number15: simple_expression : term

2

line number15: expression : simple expression

2

line number15: logic_expression : rel_expression

2

line number15: expression : variable ASSIGNOP logic expression

b=2

line number15: expression_statement : expression SEMICOLON

b=2;

line number15: statement : expression_statement

b=2;

line number15: statement_list : statement_list statement

int a,b;
a=1;
b=2;

line number16: variable : ID

a

line number16: variable : ID

a

line number16: factor : variable

a

line number16: unary_expression : factor

a

line number16: term : unary_expression

a

line number16: simple_expression : term

a

line number16: expression : simple expression

a

line number16: logic_expression : rel_expression

a

line number16: argument_list : logic_expression

a

line number16: variable : ID

b

line number16: factor : variable

b

line number16: unary_expression : factor

b

line number16: term : unary_expression

b

line number16: simple_expression : term

b

line number16: expression : simple expression

b

line number16: logic_expression : rel_expression

b

line number16: argument_list : arguments COMMA logic_expression

a,b

line number16: argument_list : arguments

a,b

line number16: factor : ID LPAREN argument_list RPAREN

g ( a,b )

line number16: unary_expression : factor

g ( a,b )

line number16: term : unary_expression

g ( a,b )

line number16: simple_expression : term

g ( a,b )

line number16: expression : simple expression

g ( a,b )

line number16: logic_expression : rel_expression

g ( a,b )

line number16: expression : variable ASSIGNOP logic expression

a=g ( a,b )

line number16: expression_statement : expression SEMICOLON

a=g ( a,b );

line number16: statement : expression_statement

a=g ( a,b );

line number16: statement_list : statement_list statement

int a,b;
a=1;
b=2;
a=g ( a,b );

line number17: statement : PRINTLN LPAREN expression RPAREN SEMICOLON

println(a);

line number17: statement_list : statement_list statement

int a,b;
a=1;
b=2;
a=g ( a,b );
println(a);

line number18: factor : CONST_INT

0

line number18: unary_expression : factor

0

line number18: term : unary_expression

0

line number18: simple_expression : term

0

line number18: expression : simple expression

0

line number18: logic_expression : rel_expression

0

line number18: expression : logic expression

0

line number18: statement : RETURN expression

return 0;

line number18: statement_list : statement_list statement

int a,b;
a=1;
b=2;
a=g ( a,b );
println(a);
return 0;

line number19: compound_statement : LCURL statement_list RCURL

{
int a,b;
a=1;
b=2;
a=g ( a,b );
println(a);
return 0;
}

print all scopes
 ScopeTable: 1_3

7--> < a ,ID >
8--> < b ,ID >
 ScopeTable: 1

12--> < f ,ID >
13--> < g ,ID >
16--> < main ,ID >
line number19: func_definition : type_specifier ID LPAREN RPAREN compound_statement

int main ( ) {
int a,b;
a=1;
b=2;
a=g ( a,b );
println(a);
return 0;
}


line number19: unit: function_definition 

int main ( ) {
int a,b;
a=1;
b=2;
a=g ( a,b );
println(a);
return 0;
}


line number19: program: program unit 

int f ( int a ) {
return 2*a;
a=9;
}

int g ( int a,int b ) {
int x;
x=f ( a )+a+b;
return x;
}

int main ( ) {
int a,b;
a=1;
b=2;
a=g ( a,b );
println(a);
return 0;
}


line number20: f PROC 
	POP BP
	POP a1_1
	PUSH BP
	mov ax, 2
	mov bx, a1_1
	imul bx
	mov temp_0, ax
	pop bp
	push temp_0
	mov ax,9
	mov a1_1, ax
	PUSH BP
	RET
f ENDP
g PROC 
	POP BP
	POP b1_2
	POP a1_2
	PUSH BP
	push ax
	push bx
	push cx
	push dx
	push a1_2
	call f
	pop temp_1
	pop dx
	pop cx
	pop bx
	pop ax
	mov ax, temp_1
	add ax, a1_2
	mov temp_2, ax
	mov ax, temp_2
	add ax, b1_2
	mov temp_3, ax
	mov ax,temp_3
	mov a1_1, ax
	pop bp
	push a1_1
	PUSH BP
	RET
g ENDP
MAIN PROC
MOV AX, @DATA
MOV DS, AX
	mov ax,1
	mov a1_1, ax
	mov ax,2
	mov temp_0, ax
	push ax
	push bx
	push cx
	push dx
	push a1_1
	push temp_0
	call g
	pop temp_4
	pop dx
	pop cx
	pop bx
	pop ax
	mov ax,temp_4
	mov a1_1, ax
	mov ax, a1_1
	mov print_var , ax
	call println
	pop bp
	push 0
MOV AX, 4C00h
INT 21h
MAIN ENDP
END MAIN

start: program
print all scopes
 ScopeTable: 1

12--> < f ,ID >
13--> < g ,ID >
16--> < main ,ID >
total no. of errors: 2
total no. of lines20
